import { BigNumber } from '@0xproject/utils';
import { BlockParam, ContractEventArg, LogWithDecodedArgs, Order, SignedOrder } from '@0xproject/types';
import * as Web3 from 'web3';
import { EtherTokenContractEventArgs, EtherTokenEvents } from './contract_wrappers/generated/ether_token';
import { ExchangeContractEventArgs, ExchangeEvents } from './contract_wrappers/generated/exchange';
import { TokenContractEventArgs, TokenEvents } from './contract_wrappers/generated/token';
export declare enum ZeroExError {
    ExchangeContractDoesNotExist = "EXCHANGE_CONTRACT_DOES_NOT_EXIST",
    ZRXContractDoesNotExist = "ZRX_CONTRACT_DOES_NOT_EXIST",
    EtherTokenContractDoesNotExist = "ETHER_TOKEN_CONTRACT_DOES_NOT_EXIST",
    TokenTransferProxyContractDoesNotExist = "TOKEN_TRANSFER_PROXY_CONTRACT_DOES_NOT_EXIST",
    TokenRegistryContractDoesNotExist = "TOKEN_REGISTRY_CONTRACT_DOES_NOT_EXIST",
    TokenContractDoesNotExist = "TOKEN_CONTRACT_DOES_NOT_EXIST",
    UnhandledError = "UNHANDLED_ERROR",
    UserHasNoAssociatedAddress = "USER_HAS_NO_ASSOCIATED_ADDRESSES",
    InvalidSignature = "INVALID_SIGNATURE",
    ContractNotDeployedOnNetwork = "CONTRACT_NOT_DEPLOYED_ON_NETWORK",
    InsufficientAllowanceForTransfer = "INSUFFICIENT_ALLOWANCE_FOR_TRANSFER",
    InsufficientBalanceForTransfer = "INSUFFICIENT_BALANCE_FOR_TRANSFER",
    InsufficientEthBalanceForDeposit = "INSUFFICIENT_ETH_BALANCE_FOR_DEPOSIT",
    InsufficientWEthBalanceForWithdrawal = "INSUFFICIENT_WETH_BALANCE_FOR_WITHDRAWAL",
    InvalidJump = "INVALID_JUMP",
    OutOfGas = "OUT_OF_GAS",
    NoNetworkId = "NO_NETWORK_ID",
    SubscriptionNotFound = "SUBSCRIPTION_NOT_FOUND",
    SubscriptionAlreadyPresent = "SUBSCRIPTION_ALREADY_PRESENT",
    TransactionMiningTimeout = "TRANSACTION_MINING_TIMEOUT",
}
export declare enum InternalZeroExError {
    NoAbiDecoder = "NO_ABI_DECODER",
    ZrxNotInTokenRegistry = "ZRX_NOT_IN_TOKEN_REGISTRY",
    WethNotInTokenRegistry = "WETH_NOT_IN_TOKEN_REGISTRY",
}
export declare type OrderAddresses = [string, string, string, string, string];
export declare type OrderValues = [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber];
export declare type LogEvent = Web3.LogEntryEvent;
export interface DecodedLogEvent<ArgsType> {
    isRemoved: boolean;
    log: LogWithDecodedArgs<ArgsType>;
}
export declare type EventCallback<ArgsType> = (err: null | Error, log?: DecodedLogEvent<ArgsType>) => void;
export declare type EventWatcherCallback = (err: null | Error, log?: LogEvent) => void;
export declare enum ExchangeContractErrCodes {
    ERROR_FILL_EXPIRED = 0,
    ERROR_FILL_NO_VALUE = 1,
    ERROR_FILL_TRUNCATION = 2,
    ERROR_FILL_BALANCE_ALLOWANCE = 3,
    ERROR_CANCEL_EXPIRED = 4,
    ERROR_CANCEL_NO_VALUE = 5,
}
export declare enum ExchangeContractErrs {
    OrderFillExpired = "ORDER_FILL_EXPIRED",
    OrderCancelExpired = "ORDER_CANCEL_EXPIRED",
    OrderCancelAmountZero = "ORDER_CANCEL_AMOUNT_ZERO",
    OrderAlreadyCancelledOrFilled = "ORDER_ALREADY_CANCELLED_OR_FILLED",
    OrderFillAmountZero = "ORDER_FILL_AMOUNT_ZERO",
    OrderRemainingFillAmountZero = "ORDER_REMAINING_FILL_AMOUNT_ZERO",
    OrderFillRoundingError = "ORDER_FILL_ROUNDING_ERROR",
    FillBalanceAllowanceError = "FILL_BALANCE_ALLOWANCE_ERROR",
    InsufficientTakerBalance = "INSUFFICIENT_TAKER_BALANCE",
    InsufficientTakerAllowance = "INSUFFICIENT_TAKER_ALLOWANCE",
    InsufficientMakerBalance = "INSUFFICIENT_MAKER_BALANCE",
    InsufficientMakerAllowance = "INSUFFICIENT_MAKER_ALLOWANCE",
    InsufficientTakerFeeBalance = "INSUFFICIENT_TAKER_FEE_BALANCE",
    InsufficientTakerFeeAllowance = "INSUFFICIENT_TAKER_FEE_ALLOWANCE",
    InsufficientMakerFeeBalance = "INSUFFICIENT_MAKER_FEE_BALANCE",
    InsufficientMakerFeeAllowance = "INSUFFICIENT_MAKER_FEE_ALLOWANCE",
    TransactionSenderIsNotFillOrderTaker = "TRANSACTION_SENDER_IS_NOT_FILL_ORDER_TAKER",
    MultipleMakersInSingleCancelBatchDisallowed = "MULTIPLE_MAKERS_IN_SINGLE_CANCEL_BATCH_DISALLOWED",
    InsufficientRemainingFillAmount = "INSUFFICIENT_REMAINING_FILL_AMOUNT",
    MultipleTakerTokensInFillUpToDisallowed = "MULTIPLE_TAKER_TOKENS_IN_FILL_UP_TO_DISALLOWED",
    BatchOrdersMustHaveSameExchangeAddress = "BATCH_ORDERS_MUST_HAVE_SAME_EXCHANGE_ADDRESS",
    BatchOrdersMustHaveAtLeastOneItem = "BATCH_ORDERS_MUST_HAVE_AT_LEAST_ONE_ITEM",
}
export interface ContractEvent {
    logIndex: number;
    transactionIndex: number;
    transactionHash: string;
    blockHash: string;
    blockNumber: number;
    address: string;
    type: string;
    event: string;
    args: ContractEventArgs;
}
export declare type ContractEventArgs = ExchangeContractEventArgs | TokenContractEventArgs | EtherTokenContractEventArgs;
export declare type TokenMetadata = [string, string, string, number, string, string];
export interface Token {
    name: string;
    address: string;
    symbol: string;
    decimals: number;
}
export interface TxOpts {
    from: string;
    gas?: number;
    value?: BigNumber;
    gasPrice?: BigNumber;
}
export interface TokenAddressBySymbol {
    [symbol: string]: string;
}
export declare type ContractEvents = TokenEvents | ExchangeEvents | EtherTokenEvents;
export interface IndexedFilterValues {
    [index: string]: ContractEventArg;
}
export interface BlockRange {
    fromBlock: BlockParam;
    toBlock: BlockParam;
}
export declare type DoneCallback = (err?: Error) => void;
export interface OrderCancellationRequest {
    order: Order | SignedOrder;
    takerTokenCancelAmount: BigNumber;
}
export interface OrderFillRequest {
    signedOrder: SignedOrder;
    takerTokenFillAmount: BigNumber;
}
export declare type AsyncMethod = (...args: any[]) => Promise<any>;
export declare type SyncMethod = (...args: any[]) => any;
/**
 * We re-export the `Web3.Provider` type specified in the Web3 Typescript typings
 * since it is the type of the `provider` argument to the `ZeroEx` constructor.
 * It is however a `Web3` library type, not a native `0x.js` type. To learn more
 * about providers, visit https://0xproject.com/wiki#Web3-Provider-Explained
 */
export declare type Web3Provider = Web3.Provider;
export interface OrderStateWatcherConfig {
    orderExpirationCheckingIntervalMs?: number;
    eventPollingIntervalMs?: number;
    expirationMarginMs?: number;
    cleanupJobIntervalMs?: number;
}
export interface ZeroExConfig {
    networkId: number;
    gasPrice?: BigNumber;
    exchangeContractAddress?: string;
    zrxContractAddress?: string;
    tokenRegistryContractAddress?: string;
    tokenTransferProxyContractAddress?: string;
    orderWatcherConfig?: OrderStateWatcherConfig;
}
export declare type ArtifactContractName = 'ZRX' | 'TokenTransferProxy' | 'TokenRegistry' | 'Token' | 'Exchange' | 'EtherToken';
export interface Artifact {
    contract_name: ArtifactContractName;
    abi: Web3.ContractAbi;
    networks: {
        [networkId: number]: {
            address: string;
        };
    };
}
export interface ValidateOrderFillableOpts {
    expectedFillTakerTokenAmount?: BigNumber;
}
export interface MethodOpts {
    defaultBlock?: Web3.BlockParam;
}
export interface TransactionOpts {
    gasPrice?: BigNumber;
    gasLimit?: number;
}
export interface OrderTransactionOpts extends TransactionOpts {
    shouldValidate?: boolean;
}
export declare type FilterObject = Web3.FilterObject;
export declare enum TradeSide {
    Maker = "maker",
    Taker = "taker",
}
export declare enum TransferType {
    Trade = "trade",
    Fee = "fee",
}
export interface OrderRelevantState {
    makerBalance: BigNumber;
    makerProxyAllowance: BigNumber;
    makerFeeBalance: BigNumber;
    makerFeeProxyAllowance: BigNumber;
    filledTakerTokenAmount: BigNumber;
    cancelledTakerTokenAmount: BigNumber;
    remainingFillableMakerTokenAmount: BigNumber;
    remainingFillableTakerTokenAmount: BigNumber;
}
export interface OrderStateValid {
    isValid: true;
    orderHash: string;
    orderRelevantState: OrderRelevantState;
}
export interface OrderStateInvalid {
    isValid: false;
    orderHash: string;
    error: ExchangeContractErrs;
}
export declare type OrderState = OrderStateValid | OrderStateInvalid;
export declare type OnOrderStateChangeCallback = (err: Error | null, orderState?: OrderState) => void;
