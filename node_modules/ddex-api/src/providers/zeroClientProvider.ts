const ProviderEngine = require("web3-provider-engine")
const DefaultFixture = require('web3-provider-engine/subproviders/default-fixture.js')
const NonceTrackerSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js')
const CacheSubprovider = require('web3-provider-engine/subproviders/cache.js')
const FilterSubprovider = require('web3-provider-engine/subproviders/filters.js')
const InflightCacheSubprovider = require('web3-provider-engine/subproviders/inflight-cache')
const HookedWalletSubprovider = require('web3-provider-engine/subproviders/hooked-wallet.js')
const SanitizingSubprovider = require('web3-provider-engine/subproviders/sanitizer.js')
const RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js')
const FetchSubprovider = require('web3-provider-engine/subproviders/fetch.js')
// const VMSubprovider = require('web3-provider-engine/subproviders/vm.js')
const EthTx = require('ethereumjs-tx')
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')

export function ZeroClientProvider(opts: any) {
  opts = opts || {}

  const engine = new ProviderEngine()

  // static
  const staticSubprovider = new DefaultFixture(opts.static)
  engine.addProvider(staticSubprovider)

  // nonce tracker
  engine.addProvider(new NonceTrackerSubprovider())

  // engine.addProvider(new VMSubprovider())

  // sanitization
  const sanitizer = new SanitizingSubprovider()
  engine.addProvider(sanitizer)

  // cache layer
  const cacheSubprovider = new CacheSubprovider()
  engine.addProvider(cacheSubprovider)

  // filters
  const filterSubprovider = new FilterSubprovider()
  engine.addProvider(filterSubprovider)

  // inflight cache
  const inflightCache = new InflightCacheSubprovider()
  engine.addProvider(inflightCache)

  // id mgmt
  const idmgmtSubprovider = new HookedWalletSubprovider({
    getAccounts: opts.getAccounts,
    getPrivateKey: opts.getPrivateKey,
    signTransaction: function (txData: any, cb: any) {
      // defaults
      if (txData.gas !== undefined) txData.gasLimit = txData.gas
      txData.value = txData.value || '0x00'
      txData.data = ethUtil.addHexPrefix(txData.data)

      opts.getPrivateKey(txData.from, function (err: any, privateKey: any) {
        if (err) return cb(err)

        var tx = new EthTx(txData)
        tx.sign(privateKey)
        cb(null, '0x' + tx.serialize().toString('hex'))
      })
    },
    signMessage: function (msgParams: any, cb: any) {
      opts.getPrivateKey(msgParams.from, function (err: any, privateKey: any) {
        if (err) return cb(err)

        // var msgHash = ethUtil.sha3(msgParams.data)
        // var msgHash = ethUtil.hashPersonalMessage(ethUtil.toBuffer(msgParams.data))
        var sig = ethUtil.ecsign(ethUtil.toBuffer(msgParams.data), privateKey)
        var serialized = ethUtil.bufferToHex(sigUtil.concatSig(sig.v, sig.r, sig.s))
        cb(null, serialized)
      })
    },
    signPersonalMessage: function (msgParams: any, cb: any) {
      opts.getPrivateKey(msgParams.from, function (err: any, privateKey: any) {
        if (err) return cb(err)
        const serialized = sigUtil.personalSign(privateKey, msgParams)
        cb(null, serialized)
      })
    },
    signTypedMessage: function (msgParams: any, cb: any) {
      opts.getPrivateKey(msgParams.from, function (err: any, privateKey: any) {
        if (err) return cb(err)
        const serialized = sigUtil.signTypedData(privateKey, msgParams)
        cb(null, serialized)
      })
    }
  })
  engine.addProvider(idmgmtSubprovider)

  // data source
  const fetchSubprovider = new FetchSubprovider({
    rpcUrl: opts.rpcUrl,
    originHttpHeaderKey: opts.originHttpHeaderKey,
  })
  engine.addProvider(fetchSubprovider)

  engine.on('error', function (err: any) {
    // report connectivity errors
    console.error(err.stack)
  })

  engine.start()
  return engine
}