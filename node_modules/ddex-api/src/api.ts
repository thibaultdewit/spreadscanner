import axios, { AxiosResponse } from 'axios'
import BigNumber from 'bignumber.js'
import { ZeroEx, SignedOrder, Order as ZeroExOrder } from '0x.js'
import { Ticker, Account, Order, Token, Trade, CommonTransaction, OrderBookSnapshot, Announcement } from "./models"
import * as Web3 from "web3"

BigNumber.config({ EXPONENTIAL_AT: 1000 })

import {
  DDEXApiParams,

  OnBookChangeEventJson,
  CreateOrderParams,
  CreateOrderResponse,
  CreateCommonTransactionResponse,
  GetOrdersResponse,
  CancelOrderResponse,
  GetBookResponse,
  GetTokensResponse,
  GetAccountResponse,
  GetTradesResponse,
  GetTickersResponse,
  GetServerStatusResponse,
  GetCommonTransactionsResponse,
  CommonTransactionJson,
  TradeLimitResponseJson,
  TradeLimit,
  AnnouncementJson,
  GetAnnouncementsReponse,

  OrderJson,
  TickerJson,
  TradeJson,
  TokenJson
} from "./types"

export class DDEXApi {
  public account: string
  public signature: string

  public serverURL: string
  public url: string
  public zeroEx: ZeroEx
  public relayer: string
  public feeRate: BigNumber
  public web3: Web3

  private shouldAddPersonalMessagePrefix: boolean
  private minimumFeeAmountCache: BigNumber
  private etherToken: Token

  constructor({ account, serverURL, apiVersion, zeroEx, relayer, feeRate, web3 }: DDEXApiParams) {
    this.serverURL = serverURL
    this.url = `${serverURL}/api/${apiVersion || "v1"}`
    if (account) {
      this.account = account
    }
    if (zeroEx) {
      this.zeroEx = zeroEx
    }
    if (web3) {
      this.web3 = web3
    }
    this.relayer = relayer
    this.feeRate = new BigNumber(feeRate || "0.003")
    this.shouldAddPersonalMessagePrefix = false
  }

  private async constructSignedOrder(makerTokenAddress: string, makerTokenAmount: BigNumber, takerTokenAddress: string, takerTokenAmount: BigNumber): Promise<{ signedOrder: SignedOrder, orderHash: string }> {
    const feeRecipient = "0xe269e891a2ec8585a378882ffa531141205e92e9"

    const order: ZeroExOrder = {
      exchangeContractAddress: this.zeroEx.exchange.getContractAddress(),
      expirationUnixTimestampSec: new BigNumber(Math.floor((new Date).getTime() / 1000) + 3600 * 24 * 365 * 1000),
      feeRecipient,
      maker: this.account,
      makerFee: new BigNumber("0"),
      salt: ZeroEx.generatePseudoRandomSalt(),
      taker: this.relayer,
      takerFee: new BigNumber("0"),
      makerTokenAddress,
      makerTokenAmount,
      takerTokenAddress,
      takerTokenAmount,
    }

    const orderHash = ZeroEx.getOrderHashHex(order)
    const signedOrder: SignedOrder = { ...order, ecSignature: await this.zeroEx.signOrderHashAsync(orderHash, this.account, this.shouldAddPersonalMessagePrefix) }

    return {
      signedOrder,
      orderHash
    }
  }

  public async buildOrder(price: string, amount: string, side: string, currentTradeToken: Token, feeAmount?: string): Promise<CreateOrderParams> {
    if (!this.zeroEx) {
      throw new Error("create order need zeroEx")
    }

    const _feeAmount = feeAmount ? new BigNumber(feeAmount) : await this.calculateFee(price, amount)
    const _price = new BigNumber(price)
    const _amount = new BigNumber(amount)

    // if (_price.lte("0")) {
    //   throw new Error("price should > 0")
    // }

    // if (_amount.lte("0")) {
    //   throw new Error("amount should > 0")
    // }

    const etherTokenAddress = (await this.getEtherToken()).address

    let makerTokenAmount, makerTokenAddress, takerTokenAmount, takerTokenAddress

    if (side == "buy") {
      makerTokenAmount = _price.mul(_amount).add(_feeAmount).mul(Math.pow(10, 18)).round(0, BigNumber.ROUND_DOWN)
      makerTokenAddress = etherTokenAddress
      takerTokenAmount = _amount.mul(Math.pow(10, currentTradeToken.decimals)).round(0, BigNumber.ROUND_DOWN)
      takerTokenAddress = currentTradeToken.address
    } else {
      makerTokenAmount = _amount.mul(Math.pow(10, currentTradeToken.decimals)).round(0, BigNumber.ROUND_DOWN)
      makerTokenAddress = currentTradeToken.address
      takerTokenAmount = _price.mul(_amount).sub(_feeAmount).mul(Math.pow(10, 18)).round(0, BigNumber.ROUND_DOWN)
      takerTokenAddress = etherTokenAddress
    }

    // const balance = await this.zeroEx.token.getBalanceAsync(makerTokenAddress, account)
    // const allowance = await this.zeroEx.token.getAllowanceAsync(makerTokenAddress, account, this.zeroEx.proxy.getContractAddress())

    // if (side === "buy") {
    //   if (makerTokenAmount.gt(balance)) {
    //     throw new Error(`no enough ETH balance (amount: ${makerTokenAmount.toString()}, balance: ${balance.toString()})`)
    //   }

    //   if (makerTokenAmount.gt(allowance)) {
    //     throw new Error(`no enough ETH allowance (amount: ${makerTokenAmount.toString()}, allowance: ${allowance.toString()})`)
    //   }
    // } else {
    //   if (makerTokenAmount.gt(balance)) {
    //     throw new Error(`no enough ${currentTradeToken.symbol} balance (amount: ${makerTokenAmount.toString()}, balance: ${balance.toString()})`)
    //   }

    //   if (makerTokenAmount.gt(allowance)) {
    //     throw new Error(`no enough ${currentTradeToken.symbol} allowance (amount: ${makerTokenAmount.toString()}, allowance: ${allowance.toString()})`)
    //   }
    // }

    const { signedOrder, orderHash } = await this.constructSignedOrder(makerTokenAddress, makerTokenAmount, takerTokenAddress, takerTokenAmount)
    const pair = `${currentTradeToken.symbol}-ETH`

    return {
      orderHash,
      signedOrder,
      price,
      side,
      amount,
      pair,
      fee: this.feeRate,
      feeAmount: _feeAmount
    }
  }

  public async calculateFee(price: BigNumber | string, amount: BigNumber | string): Promise<BigNumber> {
    return BigNumber.max(
      new BigNumber(amount).mul(price).mul(this.feeRate), await this.getMinimumFeeAmount()
    )
  }

  private async getMinimumFeeAmount(): Promise<BigNumber> {
    if (this.minimumFeeAmountCache) {
      return this.minimumFeeAmountCache
    }

    setTimeout(() => {
      delete this.minimumFeeAmountCache
    }, 30000)

    this.minimumFeeAmountCache = (await this.getTradeLimit()).minimumFeeAmount
    return this.minimumFeeAmountCache
  }

  public async getTradeLimit(): Promise<TradeLimit> {
    let url = `${this.url}/status/limit`

    const res: AxiosResponse<TradeLimitResponseJson> = await axios.get(url)
    const result: TradeLimit = {
      minimumFeeAmount: new BigNumber(res.data.minimumFeeAmount),
      maximumEtherSize: new BigNumber(res.data.maximumEtherSize),
    }

    return result
  }

  static loginMessage(account: string): string {
    return `DDEX.io\n${account}\nLOGIN`
  }

  async auth() {
    this.signature = await new Promise((resolve: (signature: string) => void, reject) => {
      this.web3.personal!.sign(this.web3.toHex(DDEXApi.loginMessage(this.account)), this.account, (err, signature) => {
        resolve(signature)
      })
    })
  }

  private getPair(token: Token): string {
    return `${token.symbol}-ETH`
  }

  private async getEtherToken(): Promise<Token> {
    if (this.etherToken) {
      return this.etherToken
    }
    const tokens = await this.getTokens()
    this.etherToken = tokens.find((t) => t.symbol === "WETH")!
    return this.etherToken
  }

  public async placeOrder(dexOrder: CreateOrderParams): Promise<CreateOrderResponse> {
    const res: AxiosResponse<CreateOrderResponse> = await axios.post(`${this.url}/orders`, dexOrder)
    return res.data
  }

  public async createOrder(side: string, currentTradeToken: Token, price: string, amount: string, feeAmount?: string): Promise<CreateOrderResponse> {
    const dexOrder = await this.buildOrder(price, amount, side, currentTradeToken, feeAmount)
    return this.placeOrder(dexOrder)
  }

  // need auth
  public async getOrders(pair?: string): Promise<Order[]> {
    let url = `${this.url}/orders?account=${this.account}`
    if (pair) {
      url = `${url}&pair=${pair}`
    }
    const res: AxiosResponse<GetOrdersResponse> = await axios.get(url, {
      headers: { "DDEX-Signature": this.signature }
    })

    return res.data.orders.map((orderJson: OrderJson) => Order.fromJSON(orderJson))
  }

  // need auth
  public async cancelOrder(orderHash: string): Promise<CancelOrderResponse> {
    const res: AxiosResponse<CancelOrderResponse> = await axios.delete(`${this.url}/orders/${orderHash}`, {
      headers: { "DDEX-Signature": this.signature }
    })
    return res.data
  }

  public async getTokens(): Promise<Token[]> {
    const res: AxiosResponse<GetTokensResponse> = await axios.get(`${this.url}/tokens`)
    return res.data.tokens.map((tokenJson: TokenJson) => Token.fromJSON(tokenJson))
  }

  public async getTrades(pair: string): Promise<Trade[]> {
    const res: AxiosResponse<GetTradesResponse> = await axios.get(`${this.url}/trades/${pair}?account=${this.account}`)
    return res.data.trades.map((tradeJson: TradeJson) => Trade.fromJSON(tradeJson))
  }

  public async getAllTrades(pair: string): Promise<Trade[]> {
    const res: AxiosResponse<GetTradesResponse> = await axios.get(`${this.url}/trades/${pair}`)
    return res.data.trades.map((tradeJson: TradeJson) => Trade.fromJSON(tradeJson))
  }

  public async getBook(pair: string): Promise<OrderBookSnapshot> {
    const res: AxiosResponse<GetBookResponse> = await axios.get(`${this.url}/books/${pair}`)
    return OrderBookSnapshot.fromJSON(res.data.book)
  }

  public async getTickers(): Promise<Ticker[]> {
    const res: AxiosResponse<GetTickersResponse> = await axios.get(`${this.url}/tickers`)
    return res.data.tickers.map((tickerJson: TickerJson) => Ticker.fromJSON(tickerJson))
  }

  public async getServerStatus(): Promise<GetServerStatusResponse> {
    const res: AxiosResponse<GetServerStatusResponse> = await axios.get(`${this.url}/status`)
    return res.data
  }

  // need auth
  public async getAccount(): Promise<Account> {
    const res: AxiosResponse<GetAccountResponse> = await axios.get(`${this.url}/accounts/${this.account}`, {
      headers: { "DDEX-Signature": this.signature }
    })
    return Account.fromJSON(res.data.account)
  }

  // need auth
  public async createCommonTransaction(id: string, type: string, data: object): Promise<CommonTransaction> {
    const res: AxiosResponse<CreateCommonTransactionResponse> = await axios.post(`${this.url}/transactions/${this.account}`, { id, type, data }, {
      headers: { "DDEX-Signature": this.signature }
    })
    return CommonTransaction.fromJSON(res.data.transaction)
  }

  public async getCommonTransactions(): Promise<CommonTransaction[]> {
    const res: AxiosResponse<GetCommonTransactionsResponse> = await axios.get(`${this.url}/transactions/${this.account}`)
    return res.data.transactions.map((json: CommonTransactionJson) => CommonTransaction.fromJSON(json))
  }

  public async getAnnouncements(locale: string): Promise<Announcement[]> {
    const res: AxiosResponse<GetAnnouncementsReponse> = await axios.get(`${this.url}/announcements?locale=${locale}`)
    return res.data.announcements.map((json: AnnouncementJson) => Announcement.fromJSON(json))
  }
}
