"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ProviderEngine = require("web3-provider-engine");
var DefaultFixture = require('web3-provider-engine/subproviders/default-fixture.js');
var NonceTrackerSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js');
var CacheSubprovider = require('web3-provider-engine/subproviders/cache.js');
var FilterSubprovider = require('web3-provider-engine/subproviders/filters.js');
var InflightCacheSubprovider = require('web3-provider-engine/subproviders/inflight-cache');
var HookedWalletSubprovider = require('web3-provider-engine/subproviders/hooked-wallet.js');
var SanitizingSubprovider = require('web3-provider-engine/subproviders/sanitizer.js');
var RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js');
var FetchSubprovider = require('web3-provider-engine/subproviders/fetch.js');
// const VMSubprovider = require('web3-provider-engine/subproviders/vm.js')
var EthTx = require('ethereumjs-tx');
var ethUtil = require('ethereumjs-util');
var sigUtil = require('eth-sig-util');
function ZeroClientProvider(opts) {
    opts = opts || {};
    var engine = new ProviderEngine();
    // static
    var staticSubprovider = new DefaultFixture(opts.static);
    engine.addProvider(staticSubprovider);
    // nonce tracker
    engine.addProvider(new NonceTrackerSubprovider());
    // engine.addProvider(new VMSubprovider())
    // sanitization
    var sanitizer = new SanitizingSubprovider();
    engine.addProvider(sanitizer);
    // cache layer
    var cacheSubprovider = new CacheSubprovider();
    engine.addProvider(cacheSubprovider);
    // filters
    var filterSubprovider = new FilterSubprovider();
    engine.addProvider(filterSubprovider);
    // inflight cache
    var inflightCache = new InflightCacheSubprovider();
    engine.addProvider(inflightCache);
    // id mgmt
    var idmgmtSubprovider = new HookedWalletSubprovider({
        getAccounts: opts.getAccounts,
        getPrivateKey: opts.getPrivateKey,
        signTransaction: function (txData, cb) {
            // defaults
            if (txData.gas !== undefined)
                txData.gasLimit = txData.gas;
            txData.value = txData.value || '0x00';
            txData.data = ethUtil.addHexPrefix(txData.data);
            opts.getPrivateKey(txData.from, function (err, privateKey) {
                if (err)
                    return cb(err);
                var tx = new EthTx(txData);
                tx.sign(privateKey);
                cb(null, '0x' + tx.serialize().toString('hex'));
            });
        },
        signMessage: function (msgParams, cb) {
            opts.getPrivateKey(msgParams.from, function (err, privateKey) {
                if (err)
                    return cb(err);
                // var msgHash = ethUtil.sha3(msgParams.data)
                // var msgHash = ethUtil.hashPersonalMessage(ethUtil.toBuffer(msgParams.data))
                var sig = ethUtil.ecsign(ethUtil.toBuffer(msgParams.data), privateKey);
                var serialized = ethUtil.bufferToHex(sigUtil.concatSig(sig.v, sig.r, sig.s));
                cb(null, serialized);
            });
        },
        signPersonalMessage: function (msgParams, cb) {
            opts.getPrivateKey(msgParams.from, function (err, privateKey) {
                if (err)
                    return cb(err);
                var serialized = sigUtil.personalSign(privateKey, msgParams);
                cb(null, serialized);
            });
        },
        signTypedMessage: function (msgParams, cb) {
            opts.getPrivateKey(msgParams.from, function (err, privateKey) {
                if (err)
                    return cb(err);
                var serialized = sigUtil.signTypedData(privateKey, msgParams);
                cb(null, serialized);
            });
        }
    });
    engine.addProvider(idmgmtSubprovider);
    // data source
    var fetchSubprovider = new FetchSubprovider({
        rpcUrl: opts.rpcUrl,
        originHttpHeaderKey: opts.originHttpHeaderKey,
    });
    engine.addProvider(fetchSubprovider);
    engine.on('error', function (err) {
        // report connectivity errors
        console.error(err.stack);
    });
    engine.start();
    return engine;
}
exports.ZeroClientProvider = ZeroClientProvider;
